---
title: "functions"
author: "Jiatao Wang"
date: "9/22/2021"
output: html_document
---

```{r}

library(httr)
library(jsonlite)
library(dplyr)
# This is the function that input the endpoints, as well as the choices of endpoints 
#for example, the endpoint berry contains 20 choices, that is, 20 types of berry. 
# for the berry data, if the choice is 0, it returns all the berries and most of their attributes. 
# for the growth-rate data, if the choice is 0, it will returns the growth rate, corresponding formula
# as well as the levels with corresponding experience needed. In this case, all pokemon species share same 
# experience points needed to have each level up. 
# if the choice is not 0 for the growth-rate endpoint, it will return the pokemon species which are under the 
# category of growth-rate, for example, if we input choice = 1, it will return the all the pokemon species that are 
# categorized as slow growth-rate. etc....
#The total numbers categories for the growth rate is 6. if you enter the number of choice greater than 6, it will return 
# error, same rule applies to the endpoint berry


get_endpoints <- function(endpoint,choice){
  overall <- GET(paste0("https://pokeapi.co/api/v2/",endpoint))
  getdata_text_all <- content(overall,"text")
  getdata_json_all<- fromJSON(getdata_text_all, flatten = TRUE)
  look_all <- as_tibble(getdata_json_all$results)
  
  
             if(endpoint == "berry"){
                 if(choice == 0){
                    ee <- getBerry(look_all$name[1],look_all)
                          for (i in 2:length(look_all$name)){
                             ee <- rbind(ee,getBerry(look_all$name[i],look_all))
                             if (length(ee$Name)==length(look_all$name)){
                               return(ee) 
                          }
                        }
                      }
                 if(choice != 0){
                  ee <- getBerry(look_all$name[choice],look_all)
                    return(ee)
               }
             }
  
            if(endpoint == "growth-rate"){
               if(choice == 0){
                 ff <- get_growth_rate(look_all$name[1],look_all)
                    for (i in 2:length(look_all$name)){
                      ff <- cbind(ff, get_growth_rate(look_all$name[i],look_all)[,1:2])
                        if(ncol(ff)==12){
                          return(ff)
                       }
                   }
              }
               

               if(choice != 0){
                   PokeMon1 <- get_growth_species(look_all$name[choice],1,look_all)
                #for (i in 1:length(look_all$name)){
                  c = length(fromJSON(content(GET(look_all$url[choice]),"text"),flatten = TRUE)$pokemon_species$name)
                     for (j in 2:c){
                        PokeMon1 <- bind_rows(PokeMon1, get_growth_species(look_all$name[choice],j,look_all))
                          if (length(PokeMon1$species.name)==c){
                            return(PokeMon1) 
                        }
                      }
                    }
                  }
}

             
             
             
           
    
#}    

    
 

          
  
get_endpoints("growth-rate")  

Rate <- GET("https://pokeapi.co/api/v2/growth-rate/")
getdata_textRate <- content(Rate,"text")
getdata_json_Rate<- fromJSON(getdata_textRate, flatten = TRUE)
tt <- as_tibble(getdata_json_Rate$results)

PokeMon <- get_growth_species(tt$name[1],1,tt)
for (i in 1:length(tt$name)){
   for (j in 2:length(fromJSON(content(GET(tt$url[1]),"text"),flatten = TRUE)$pokemon_species$name)){
            PokeMon <- bind_rows(PokeMon, get_growth_species(tt$name[1],j,tt))
   }
}

                             
                               
 
  

get_growth_species <- function(s,i,tt) {

    url <- tt$url[which(tt$name==s)]
    r <- GET(url=url)
    x <- content(r, 'text')
    Json_x<- fromJSON(x, flatten = TRUE)
    # pull data from several end points(which are all attributes associate with growth_rate)
    Growth_Category <- s
    Growth_Formula <- Json_x$formula
    Growth_levels <- matrix(unlist(Json_x$levels$level),,1)
    Growth_experience <-matrix(unlist(Json_x$levels$experience),,1)
    species_name <- matrix(unlist(Json_x$pokemon_species$name),,1)
#for (i in 1:length(Json_x$pokemon_species$url)){
    url2<-Json_x$pokemon_species$url[i]
    r2 <-GET(url=url2)
    x2 <-content(r2, 'text')
    Json_x2<- fromJSON(x2, flatten = TRUE)
    
    pokeName <-Json_x2$name
    Base_Happiness <- Json_x2$base_happiness
    Capture_Rate <- Json_x2$capture_rate
    Color <- Json_x2$color$name
    Evolves <- ifelse(!is.null(Json_x2$evolves_from_species$name),Json_x2$evolves_from_species$name,NA)
    Generation <- Json_x2$generation$name
    Form_Switchable <- Json_x2$forms_switchable
    Habit <- ifelse(!is.null(Json_x2$habitat$name),Json_x2$habitat$name,NA)
    Hatch_COunter <- Json_x2$hatch_counter
    Shape <- Json_x2$shape$name

    
    pokemon_species <- tibble(
    species.name = pokeName,
    Growth_Category = s,
    Growth.Formula = Growth_Formula,
    BaseHappiness = Base_Happiness,
    Capture.Rate = Capture_Rate,
    Color.poke = Color,
    Evolves.poke = Evolves,
    Generation.poke = Generation,
    Form_Switchable.poke = Form_Switchable,
    Habit.poke = Habit,
    Hatch_COunter.poke =Hatch_COunter,
    Shape.poke = Shape
  )
    for (i in length(pokemon_species)){
      ifelse(!is.null(pokemon_species[i]),pokemon_species[i],NA)
    }
    
   return(pokemon_species)

    
}    

    
    #create the tibble that containing the names of the species as well cols of their attributes. 
# this works but is a little bit slow using what I wrote. 
PokeMon <- get_growth_species(Growth_Rate_look$name[1],1)
for (i in 1:length(Growth_Rate_look$name)){
  for (j in 2:length(fromJSON(content(GET(Growth_Rate_look$url[i]),"text"),flatten = TRUE)$pokemon_species$name)){
     PokeMon <- rbind(PokeMon, get_growth_species(Growth_Rate_look$name[i],j))
  }
   
}
















get_growth_rate <- function(s,tt) {

    url <- tt$url[which(tt$name==s)]
    r <- GET(url=url)
    x <- content(r, 'text')
    Json_x<- fromJSON(x, flatten = TRUE)
    # pull data from several end points(which are all attributes associate with growth_rate)
    Growth_Category <- s
    Growth_Formula <- Json_x$formula
    Growth_levels <- matrix(unlist(Json_x$levels$level),,1)
    Growth_experience <-matrix(unlist(Json_x$levels$experience),,1)
    species_name <- matrix(unlist(Json_x$pokemon_species$name),,1)

    
    #create the tibble that containing the names of the berries as well cols of their attributes. 
  df <- tibble(
     Category_s_ = Growth_Category,
     Formula_s_ = Growth_Formula,
     level = Growth_levels,
     experience = Growth_experience
     
  )
   return(df)
}



df2 <- get_growth_rate(Growth_Rate_look$name[1])
for (i in 2:length(Growth_Rate_look$name)){
    df2 <- cbind(df2, get_growth_rate(Growth_Rate_look$name[i])[,1:2])

}
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

get_endpoints("berry")
 E <- GET("https://pokeapi.co/api/v2/berry/")
  getdata_text <- content(E,"text")
  getdata_json<- fromJSON(getdata_text, flatten = TRUE)
  tt <- as_tibble(getdata_json$results)

# after getting the data set of berry containing the name and its url links, writing the function that call the attributes of each type of berry
  # caution: this function only return the single berry that you are interesed. 

  
  
  
  
  
  
  
  
  
  
  
  getBerry <- function(s,tt){
    url <- tt$url[which(tt$name==s)]
    r <- GET(url=url)
    x <- content(r, 'parsed')
    # pull data from several end points(which are all attributes associate with berries)
    berry_name <- x$name
    berry_growth_time <- x$growth_time
    berry_size <- x$size
    berry_firmness <- x$firmness$name
    berry_max_harvest <-x$max_harvest
    berry_natural_gift_power <- x$natural_gift_power
    #berry_natural_gift_type <- x$natural_gift_type
    berry_soil_dryness <- x$soil_dryness
    berry_smoothness <- x$smoothness
    #create the tibble that containing the names of the berries as well cols of their attributes. 
  berry <- tibble(
     Name = berry_name,
     Growth_Time = berry_growth_time,
     Size = berry_size,
     Firmness = berry_firmness,
     Max_Harvest = berry_max_harvest,
     Natural_Gift_Power = berry_natural_gift_power,
     #Natrual_Gift_Type = berry_natural_gift_type,
     Soil_Dryness = berry_soil_dryness,
     Smoothness =  berry_smoothness
  )
   return(berry)
}


# using a loop to get all the berry and its attributes by using the function getB 
# is I use the wrapper function in this part, it will return the list of all rbind datasets 
# from the obs 2 to obs 20 each. so I abandoned using wrapper function, just used a for loop inorder to get the dataframe. 
df <- getB(berry_look$name[1],berry_look)
for (i in 2:length(berry_look$name)){
    df <- rbind(df, getB(berry_look$name[i],berry_look))
}































































```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
